#### 分布式、微服务知识点

> 参考《高可用可伸缩微服务架构》

#####  领域驱动有了解吗？什么是领域驱动模型？

##### JWT有了解吗，什么是JWT

##### 说说如何设计一个良好的 API

##### 说说 CAP 定理、BASE 理论

CAP: 

 C(一致性  Consistency)，所有节点上的数据时刻保持一致

 A(可用性 Avaliability)，每个请求都能够收到一个响应，无论响应成功或者失败

P(分区容错 Partition-tolerance)，系统出现脑裂以后，可能导致某些server 与集群中的机器失去联系

BASE： 

XA事务虽然可以保证数据库在分布式系统下的ACID特性，但会带来性能方面的影响

eBay提出了BASE理论

Basically available：数据库采用分片模式，把100w的用户数据分布在5个实例上，如果破坏了其中一个实例，仍然可以保证80%的用户可用

Soft-state：在基于client-server模式的系统中，server端是否有状态，决定了系统是否具备良好的水平扩展、负载均衡、故障恢复等特性。Server端承诺会维护client端状态数据，这个状态仅维持一小段时间，这段时间以后，server端会丢弃这个状态，恢复正常状态

Eventually consistent：数据最终一致性



##### 微服务与 SOA 的区别

SOA即面向服务架构，关注点是服务，现有的分布式服务化技术有Dubbo等

1. 微服务是一种经过改良架构设计的SOA解决方案，是面向服务的交互方案
2. 微服务更趋向于以自治的方式产生价值
3. 微服务与敏捷开发的思想高度结合在一起，服务的定义更加清晰，同时减少了企业ESB开发的复杂性
4. 微服务是SOA思想的一种提炼
5. SOA是重ESB,微服务是轻网关

##### 如何拆分服务、水平分割、垂直分割

##### 如何应对微服务的链式调用异常

##### 如何快速追踪与定位问题

##### 如何保证微服务的安全、认证



##### 如何保证接口的幂等性

1. 乐观锁，使用版本号
2. 唯一索引，可以把作为唯一索引的键单独称为一个表，作为去重表
3. 分布式锁，使用setnx，如果setnx返回0就代表重复请求，同时在业务逻辑处理完成后，删除缓存



##### 说说最终一致性的实现方案



##### 缓存、数据库一致性方案

1. 更新操作，先删除缓存，再修改数据库，如果数据库失败，数据库中的还是旧数据，缓存是空的，在查询的时候，发现缓存是空的，就会从数据库取数据，然后更新到缓存中

2. 方案一在高并发下，先删除了缓存，但数据库还没修改成功，此时读请求过来，发现没有缓存，就会去查询数据库，放入缓存，随后更新数据库操作完成了，此时缓存中的数据是旧数据，与数据库中的数据不一致。

    方案如下：

    在请求的时候，发现没有缓存，就发一个更新操作，到JVM队列，主线程循环判断缓存是否更新，并设置超时时间，如果超时，就直接取数据库数据，返回旧数据。JVM队列中，如果之前已经有更新操作，自动丢弃后面的更新操作，防止频繁更新。

    如果实例服务是分布式部署，需要将同一请求路由到同一个实例，可以通过某个请求参数的hash路由，也可以通过Nginx的hash路由功能

##### 
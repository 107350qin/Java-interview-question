#### 锁

> 《Java并发编程的艺术》、《Java并发编程之美》

##### 自旋锁、自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁

自旋锁：开启线程执行一个忙循环，直到需要更新的值为期待值为止  
自适应自旋：自旋时间不再固定，由前一次在同一个锁上的自旋时间及锁的拥有者状态来决定，比如在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将自旋等待更长时间，如果很少成功获得过锁，那很可能会忽略掉自旋过程，以避免CPU资源浪费。  
锁消除：JIT在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除  
锁粗化：如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展到整个序列的外部  
轻量级锁：加锁是通过同步对象的对象头进行操作的，首先会在当前线程的栈帧中建立一个名为锁记录的空间，存储锁对象目前的Mark Word拷贝，会加Displaced前缀，然后通过CAS尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功，就获得了该对象的锁，如果失败，会检查Mark Word是否指向当前线程的栈帧，如果是就说明已经获得了锁，如果没有就说明有其他线抢占，轻量锁就会膨胀成重量级锁；解锁也是通过CAS来操作，就是将Mark Word 替换为原来的值    
偏向锁：锁偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再同步。-XX:+UseBiasedLocking 开启偏向锁

##### 公平锁、非公平锁

公平锁：根据线程请求锁的顺序来获取锁  
非公平锁：抢占式获取锁

##### AbstractQueuedSynchronizer的作用

抽象同步队列简称AQS,是实现同步器的基础组件，并发包中的锁都是基于其实现的

##### JDK8新增的锁

StampedLock 提供了三种模式的读写控制，当调用获取锁的系列函数时，会返回一个long型变量，支持在一定条件下三种模式的相互转换  
写锁writeLock: 一个排它锁或者独占锁，并且写锁不可重入  
悲观读锁readLock: 共享锁，在没有线程独占获取写锁的情况下，多个线程可以同时获取该锁，如果已经有其他线程持有写锁，则其他线程请求读锁会被阻塞  
乐观读锁tryOptimisticRead: 在操作数据前并没有通过CAS设置锁的状态，仅通过位运算测试
#### 锁

> 《Java并发编程的艺术》、《Java并发编程之美》

##### Synchronized原理

Synchronized可以修饰普通方法、同步方法块、静态方法；
普通方法锁是当前实例对象，静态方法锁是当前类的Class对象，同步方法块锁是Synchonized配置的对象；
用的锁是存在对象头里的,根据mark word的锁状态来判断锁，如果锁只被同一个线程持有使用的是偏向锁，不同线程互相交替持有锁使用轻量级锁，多线程竞争使用重量级锁。锁会按偏向锁->轻量级锁->重量级锁 升级，称为锁膨胀  
 https://github.com/farmerjohngit/myblog/issues/12

##### synchronized和Lock的区别

1. synchronized 是Java内置关键字，Lock是Java类
2. synchronized 无法显式的判断是否获取锁的状态，Lock可以判断是否获取到锁
3. synchronized 会自动释放锁，Lock需要在finally中手工释放锁
4. synchronized 不同线程获取锁只有一个线程能获取成功，其他线程会一直阻塞直到获取锁，Lock有阻塞锁，也有非阻塞锁，阻塞锁还有尝试设置，功能更强
5. synchronized 可重入，不可中断，非公平，Lock锁可重入，可判断，有公平锁，非公平锁
6. Lock锁适合大量同步代码的同步问题，synchronized锁适合代码少量的同步问题

##### 自旋锁、自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁

自旋锁：开启线程执行一个忙循环，直到需要更新的值为期待值为止  
自适应自旋：自旋时间不再固定，由前一次在同一个锁上的自旋时间及锁的拥有者状态来决定，比如在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将自旋等待更长时间，如果很少成功获得过锁，那很可能会忽略掉自旋过程，以避免CPU资源浪费。  
锁消除：JIT在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除  
锁粗化：如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展到整个序列的外部  
轻量级锁：加锁是通过同步对象的对象头进行操作的，首先会在当前线程的栈帧中建立一个名为锁记录的空间，存储锁对象目前的Mark Word拷贝，会加Displaced前缀，然后通过CAS尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功，就获得了该对象的锁，如果失败，会检查Mark Word是否指向当前线程的栈帧，如果是就说明已经获得了锁，如果没有就说明有其他线程抢占，轻量锁就会膨胀成重量级锁；解锁也是通过CAS来操作，就是将Mark Word 替换为原来的值    
偏向锁：锁偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再同步。-XX:+UseBiasedLocking 开启偏向锁

##### 公平锁、非公平锁

公平锁：根据线程请求锁的顺序来获取锁  
非公平锁：抢占式获取锁

##### AbstractQueuedSynchronizer的作用

抽象同步队列简称AQS,是实现同步器的基础组件，并发包中的锁都是基于其实现的

##### JDK8新增的锁

StampedLock 提供了三种模式的读写控制，当调用获取锁的系列函数时，会返回一个long型变量，支持在一定条件下三种模式的相互转换  
写锁writeLock: 一个排它锁或者独占锁，并且写锁不可重入  
悲观读锁readLock: 共享锁，在没有线程独占获取写锁的情况下，多个线程可以同时获取该锁，如果已经有其他线程持有写锁，则其他线程请求读锁会被阻塞  
乐观读锁tryOptimisticRead: 在操作数据前并没有通过CAS设置锁的状态，仅通过位运算测试


#### Java 基础

> 《Java编程思想》、《疯狂Java：突破程序员基本功的16课.修订版》

##### 自定义注解

1. 声明注解的保留期限类型

    @Retention(RetentionPolicy.RUNTIME)表示该注解可以在运行期保留

    保留期限类型：java.lang.annotation.Retention

    SOURCE: 注解信息仅保留在目标类源代码文件中，对应的字节码文件不会保留

    CLASS: 注解信息存在于源代码、字节码文件中，但运行期JVM不能获得该注解信息

    RUNTIME: 注解信息存在于源代码、字节码文件、运行期JVM中，能够通过反射机制获取注解类信息

2. 声明注解的可以使用的目标类型

    @Target(ElementType.METHOD) 表示这个注解只能在方法上使用

    目标类型：java.lang.annotation.ElementType

    TYPE: 类、接口、注解类、Enum

    FIELD: 类成员变量或常量

    METHOD: 方法

    PARAMETER: 参数

    CONSTRUCTOR: 构造器

    LOCAL_VARIABLE: 局部变量

    ANNOTATION_TYPE: 注解

    PACKAGE: 包

3. 使用@interface 修饰类

4. 声明注解成员

    成员无入参、不能抛出异常；

    可以通过default成员指定默认值

    成员类型只能使用基本数据类型、String、Class、enums、注解类型，及上述类型的数组类型。如ForumService value()是非法的

    如果注解只有一个成员，则成员名必须取名为value()，再使用时可以忽略成员名和赋值号，如果注解类拥有多个成员时，

    对value成员赋值，可以省略value和赋值号，如果是多个成员赋值，必须使用赋值号

##### HTTP请求的GET与POST方式的区别

1. GET在浏览器回退是无害的，而POST会再次提交请求
2. GET请求会被浏览器主动cache,而POST不会，除非手动设置
3. GET请求只能进行URL编码，而POST支持多种编码
4. GET请求参数会被完整保留在浏览器历史记录中，而POST中的参数不会被保留
5. GET请求在URL中传送参数是有大小限制的，不能大于2KB,而POST可以说没有
6. GET只接受ASCII字符，而POST没有限制
7. GET参数直接暴露在URL上，而POST将数据放在request body中

##### Session与Cookie区别

Session:

服务器端会为每个访问服务端的请求分配一个会话Session，其数据存储在服务器端，不依赖浏览器端环境，因此高效安全

Cookie:

数据已文件形式存在用户浏览器端，用户可以通过浏览器禁用Cookie，用户可以对Cookie进行查看，修改，和删除

##### 列出自己常用的JDK包

常用的包：

java.lang	包装类，线程等都在该包

java.match  有BigDecimal 精确数字类型

java.util  并发，集合等都在该包内

##### equals与==的区别

1. equals 比较两个实体值是否相同，可以被覆盖，但需要遵循几个约定：

    自反性：对于任何非null的引用值x, x.equals(x)必须返回true

    对称性：对于任何非null的引用值x和y，当y.equals(x)返回true时，x.equlas(y)必须返回true

    传递性：对于任何非null的引用值x、y、z，如果x.equals(y)返回true，并且y.equals(x)也返回true，那么x.equals(z)也必须返回true

    一致性：对于任何非null的引用值x和y，只要比较对象中的所有信息没有被修改，多次调用equals一致返回true，或者false

2. == 比较两个实体的引用地址是否相等，不能覆盖，如果引用地址相等，那认为两个实体为同一个实体

##### hashCode和equals方法的区别与联系

对于覆盖了equals方法的类中，同样也要覆盖hashCode方法，如果不这样该类在散列集合中会有问题，比如HashMap中，计算key的索引位置，会调用到key.hashCode

##### 什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用

序列化是一种用来处理对象流的机制，也就是将对象的内容转化成二进制流，可以将对象持久化或者网络传输

反序列化是将二进制流还原为对象的过程

实现Java序列化，通过实现Serializable即可

##### Object类中常见的方法，为什么wait  notify会放在Object里边？

因为Java提供的锁是对象级的，每个对象都有对象头，用来存储锁

##### Arraylist 与 LinkedList 区别



##### HashMap 1.7 和 1.8 的区别

- 1.7，在发生hash冲突的时候，数据结构只有链表；  
- 1.8，数据结构有链表和红黑树，使用红黑树是为了能够提高查询效率。在链表长度达到7的，并且hash tab[]数组长度大于等于64时，将链表转换成红黑树，如果数组长度小于64，只是对数组进行扩容  
 https://blog.csdn.net/qq_21251983/article/details/90056067

##### 手写HashMap

要点：

1. 底层是数组结构
2. hash冲突的时候，转换为链表
3. 考虑扩容处理

##### HashMap在并发下会产生什么问题？有什么替代方案?(HashTable, ConcurrentHashMap)。它们两者的实现原理。

- HashMap并发下产生问题：由于在发生hash冲突，插入链表的时候，多线程会造成环链，再get的时候变成死循环，Map.size()不准确，数据丢失  
    https://www.iteye.com/blog/hwl-sz-1897468
- HashTable: 通过synchronized来修饰，效率低，多线程put的时候，只能有一个线程成功，其他线程都处于阻塞状态    
- ConcurrentHashMap：
    1.7 采用锁分段技术提高并发访问率  
     1.8 数据依旧是分段存储，但锁采用了synchronized，内部采用Node数组+链表+红黑树的结构存储，当单个链表存储数量达到红黑树阈值8时（此时链表已有元素7），存储结构转换为红黑树来存储    
     https://www.cnblogs.com/banjinbaijiu/p/9147434.html